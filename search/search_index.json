{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"KotPreferences <p>With this library you can declare preferences via kotlin delegates and observe and update them via kotlin flows. This works with any storage implementation, an implementation for JetPack DataStore is provided already.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>declare preferences via kotlin delegates</li> <li>listen to updates from preferences via <code>kotlin flows</code></li> <li>update dependencies via <code>suspend</code> functions</li> <li>use those preferences inside compose as <code>State</code>, <code>MutableState</code> or <code>StateFlow</code></li> </ul>"},{"location":"#supported-platforms","title":"Supported Platforms","text":"<p>This is a KMP (kotlin multiplatform) library and the provided modules do support following platforms.</p> Module android ios windows macos wasm Info Core <code>core</code>                    \u2714                                     \u2714                                     \u2714                                     \u2714                                     \u2714                  Storage <code>storage-datastore</code>                    \u2714                                     \u2714                                     \u2714                                     \u2714                                     -                  <code>storage-keyvalue</code>                    \u2714                                     \u2714                                     \u2714                                     \u2714                                     \u2714                  Extensions <code>extension-compose</code>                    \u2714                                     \u2714                                     \u2714                                     \u2714                                     \u2714                  Encryption <code>encryption-aes</code>                    \u2714                                     -                                     -                                     -                                     -                                 (1)              <ul> <li>(1) Currently I only provide an encryption module for android. Pull requests with implementations for other platforms are welcome.</li> </ul>"},{"location":"#demo","title":"Demo","text":"<p>A full demo is included inside the demo module, it shows nearly every usage with working examples.</p>"},{"location":"compatibility/","title":"Compatibility","text":"<p>Information about the compatibility of this library with all my other libraries can be found here.</p>"},{"location":"dependencies/","title":"Dependencies","text":""},{"location":"dependencies/#compose","title":"Compose","text":"Dependency Version Infos Jetbrains Compose Multiplatform <code>1.8.2</code> Depends on jetpack (androidx) compose <code>1.8.2</code> Jetbrains Material 3 <code>1.8.2</code> Depends on jetpack (androidx) material3 <code>1.3.2</code> <p>More details about the jetpack dependencies can be found in JetBrains Release Notes.</p> <p>Warning</p> <p>I try to use as few experimental APIs as possible, but this library does use a few experimental APIs which are still marked as experimental. I will provide new versions as soon as possible if experimental APIs change or become stable.</p>"},{"location":"dependencies/#modules","title":"Modules","text":"Module Dependency Version Core <code>core</code> - Storage <code>storage-datastore</code> - <code>storage-keyvalue</code> - Extensions <code>extension-compose</code> - Encryption <code>encryption-aes</code> -"},{"location":"me/","title":"About Me","text":""},{"location":"me/#about-me","title":"About Me","text":"<p>Check out my main homepage to get an impression of what I do and my open source libraries, android apps and garmin watchfaces that I've developed.</p> <p>https://mflisar.github.io/</p>"},{"location":"other-libraries/","title":"Other Libraries","text":""},{"location":"other-libraries/#other-libraries","title":"Other Libraries","text":"<p>Here you can find an overview of my main libraries that do all play well together including some short descriptions.</p> Utilities Library Description CacheFileProvider This is a minimal library with a few lines of code and without dependencies that offers a simple file provider (simple read only access for sharing files with other apps). FeedbackManager This is a very small library that allows you to send feedback from an app without internet permission via email, either directly or via an unintrusive notification. Libraries Library Description KotBilling A kotlin coroutine based solution for handling in app purchases for billing library version 7. Lumberjack This is a full logging library with a build in way to log to console, file or any custom place as well as optional extensions to send a log file via mail or show it on the device. Compose Image Library Description ComposeChangelog This library offers you a a changelog dialog for compose including the ability to show new logs on app start only as well as filtering and customisation. ComposeColors A simple collection of colors that can be used inside any KMP compose project. ComposeDebugDrawer This library offers you a simple and easily extendable debug drawer. ComposeDialogs A compose framework for modal dialogs. ComposePreferences This library offers you preference screens for compose including the ability of endless nesting subscreens as well as simple integration of custom preferences. ComposeThemer This is a full compose theme engine that handles applying a theme as well as updating the system ui elements. Extendible and allows to simply apply user selected themes inside your app. Unofficial Projects Library Description kmp-parcelize a kmp parcelize library that allows you to use the `@Parcelize` annotation in your kmp projects kmp-library a collection of gradle plugins for my demo projects as well as for my own apps kmp-democomposables a collection of composables that I use for my demo projects Toolbox My personal toolbox library"},{"location":"setup/","title":"Setup","text":"<p>This library is distributed via maven central.</p> <p>Add dependencies like following to use this library inside your project.</p> DependenciesVersion Catalog <p>Simply add the dependencies inside your <code>build.gradle.kts</code> file.</p> build.gradle.kts<pre><code>val kotpreferences = \"&lt;LATEST-VERSION&gt;\"\n\n// core\nimplementation(\"io.github.mflisar.kotpreferences:core:$kotpreferences\")\n\n// select a storage implementation\nimplementation(\"io.github.mflisar.kotpreferences:storage-datastore:$kotpreferences\")\nimplementation(\"io.github.mflisar.kotpreferences:storage-keyvalue:$kotpreferences\")\n\n// optional extensions\nimplementation(\"io.github.mflisar.kotpreferences:extension-compose:$kotpreferences\")\n\n// optionally add additional encryption\nimplementation(\"io.github.mflisar.kotpreferences:encryption-aes:$kotpreferences\")\n</code></pre> <p>Define the dependencies inside your <code>libs.versions.toml</code> file.</p> libs.versions.toml<pre><code>[versions]\n\nkotpreferences = \"&lt;LATEST-VERSION&gt;\"\n\n[libraries]\n\n# core\nkotpreferences-core = { module = \"io.github.mflisar.kotpreferences:core\", version.ref = \"kotpreferences\" }\n\n# select a storage implementation\nkotpreferences-storage-datastore = { module = \"io.github.mflisar.kotpreferences:storage-datastore\", version.ref = \"kotpreferences\" }\nkotpreferences-storage-keyvalue = { module = \"io.github.mflisar.kotpreferences:storage-keyvalue\", version.ref = \"kotpreferences\" }\n\n# optional extensions\nkotpreferences-extension-compose = { module = \"io.github.mflisar.kotpreferences:extension-compose\", version.ref = \"kotpreferences\" }\n\n# optionally add additional encryption\nkotpreferences-encryption-aes = { module = \"io.github.mflisar.kotpreferences:encryption-aes\", version.ref = \"kotpreferences\" }\n</code></pre> <p>And then use the definitions in your projects like following:</p> build.gradle.kts<pre><code># core\nimplementation(libs.kotpreferences.core)\n\n# select a storage implementation\nimplementation(libs.kotpreferences.storage.datastore)\nimplementation(libs.kotpreferences.storage.keyvalue)\n\n# optional extensions\nimplementation(libs.kotpreferences.extension.compose)\n\n# optionally add additional encryption\nimplementation(libs.kotpreferences.encryption.aes)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#1-define-a-settingsmodel","title":"1. Define a <code>SettingsModel</code>","text":"<pre><code>// Depending on the platform:\n//   - common: DataStoreStorage.create(name = \"preferences\")\n//   - jvm: DataStoreStorage.create(folder = File(System.getProperty(\"user.dir\")), name = \"preferences\")\n//   - android/iOS: DataStoreStorage.create(name = \"preferences\")\n//   - ...\nobject Preferences : SettingsModel(DataStoreStorage.create(name = \"preferences\")) {\n\n    // main data types\n    val someString by stringPref(\"value\")\n    val someBool by boolPref(false)\n    val someInt by intPref(123)\n    val someLong by intPref(123L)\n    val someFloat by intPref(123f)\n    val someDouble by intPref(123.0)\n\n    // enum\n    val someEnum by enumPref(Enum.Value1)\n\n    // custom\n    val someCustomClass1 by anyStringPref(TestClass.CONVERTER, TestClass()) // converts TestClass to a string and saves this string\n    val someCustomClass2 by anyIntPref(TestClass.CONVERTER, TestClass())    // converts TestClass to an int and saves this int\n    val someCustomClass3 by anyLongPref(TestClass.CONVERTER, TestClass())   // converts TestClass to a long and saves this long\n\n    // sets\n    val someStringSet by stringSetPref(setOf(\"a\"))\n    val someIntSet by intSetPref(setOf(1))\n    val someLongSet by longSetPref(setOf(1L))\n    val someFloatSet by floatSetPref(setOf(1f))\n    val someDoubleSet by doubleSetPref(setOf(1.0))\n\n    // NULLABLE vs NON NULLABLE\n    val nonNullableString by stringPref()\n    val nullableString by nullableStringPref()\n    val nonNullableInt by intPref()\n    val nullableInt by nullableIntPref()\n    val nonNullableFloat by floatPref()\n    val nullableFloat by nullableFloatPref()\n    val nonNullableDouble by doublePref()\n    val nullableDouble by nullableDoublePref()\n    val nonNullableLong by longPref()\n    val nullableLong by nullableLongPref()\n    val nonNullableBool by boolPref()\n    val nullableBool by nullableBoolPref()\n\n    // custom\n    val someCustomClass4 by nullableAnyStringPref(TestClass.CONVERTER, TestClass())\n    val someCustomClass5 by nullableAnyIntPref(TestClass.CONVERTER, TestClass())\n    val someCustomClass6 by nullableAnyLongPref(TestClass.CONVERTER, TestClass())\n}\n</code></pre>"},{"location":"usage/#2a-use-the-settingsmodel-in-plain-kotlin-flows-suspending-functions","title":"2a) Use the <code>SettingsModel</code> in plain kotlin (<code>flows</code> + <code>suspending functions</code>)","text":"<pre><code>// 1) get a flow\nval flow = Preferences.someString.flow\n\n// 2) read/update values by suspend functions\nscope.launch(Dispatchers.IO) {\n    val value = Preferences.someInt.read()\n    Preferences.someInt.update(value + 1)\n}\n</code></pre>"},{"location":"usage/#2b-use-the-settingsmodel-in-views-eg-with-lifecycle-scope","title":"2b) Use the <code>SettingsModel</code> in views (e.g. with <code>Lifecycle Scope</code>)","text":"<pre><code>// 1) simply observe a setting\nPreferences.someString.observe(lifecycleScope) {\n    L.d { \"someString = $it\"}\n}\n\n// 2) direct read (not recommended if not necessary but may be useful in many cases)\n// =&gt; simply returns read() in a blocking way)\nval name = Preferences.someString.value\n\n// 3) observe a setting once\nPreferences.someString.observeOnce(lifecycleScope) {\n    L.d { \"someString = $it\"}\n}\n\n// 4) observe ALL settings\nPreferences.changes.onEach {\n    L.d { \"[ALL SETTINGS OBSERVER] Setting '${it.setting.key}' changed its value to ${it.value}\" }\n}.launchIn(lifecycleScope)\n\n// 5) observe SOME settings\nPreferences.changes\n    .filter {\n        it.setting == Preferences.someString ||\n        it.setting == Preferences.someBool\n    }.onEach {\n        L.d { \"[SOME SETTINGS OBSERVER] Setting '${it.setting.key}' changed its value to ${it.value}\" }\n    }.launchIn(lifecycleScope)\n\n// 6) read multiple settings in a suspending way\nlifecycleScope.launch(Dispatchers.IO) {\n    val someString = Preferences.someString.read()\n    val someBool = Preferences.someBool.read()\n}\n</code></pre>"},{"location":"usage/#2c-use-the-settingsmodel-in-compose","title":"2c) Use the <code>SettingsModel</code> in <code>compose</code>","text":"<pre><code>val name = Preferences.someString.collectAsState()\nval name = Preferences.someString.collectAsStateWithLifecycle()\n\n// simply use the state inside your composables, the state will change whenever the setting behind it will change\n\nval name = Preferences.someString.asMutableState()\n\n// simple use and even update the state now\n</code></pre>"},{"location":"migration/v0.7/","title":"v0.7","text":"<p>Info</p> <p>Version <code>0.7</code> is a kotlin multiplatform rewrite, that's why some fundamantal changes needed to be done!</p> <p>Overall some things have become extension functions to provide target specific implementations. Platform specific functions and overloads have been added to provide a good single platform experience and some typos have been fixed as well.</p> <p>Following is an overview on what has changed and shows how you can migrate your project.</p>"},{"location":"migration/v0.7/#datastorestorage","title":"DataStoreStorage","text":"<p>I do provide platform specific <code>create</code> function to make single platform usage easier. On android those do look like following now:</p> <pre><code>val storage = DataStoreStorage.create(name = \"...\")\n</code></pre> <p>In MP projects you can simply use the classes themself if you want to.</p> <p>Additionally the class was moved  from <code>import com.michaelflisar.kotpreferences.datastore.DataStoreStorage</code> to <code>com.michaelflisar.kotpreferences.storage.datastore.DataStoreStorage</code>.</p>"},{"location":"migration/v0.7/#enumpref","title":"enumPref","text":"<p>The <code>enumPref</code> function that does not need an array of all enum values became an extension function and only exists on android (because the <code>Enum.entries</code> field does not exist on all platforms).</p> <p>You need to import <code>import com.michaelflisar.kotpreferences.core.enumPref</code> on android now to keep using this function.</p>"},{"location":"migration/v3.0.0/","title":"v3.0.0","text":"<p>Only the compose module has been changed like following:</p> <ul> <li>all <code>&lt;function&gt;Mapped(...)</code> functions have been removed - they are no longer needed as the a replaced with <code>&lt;function&gt;(...)</code> function overloads with a <code>mapper</code> parameter.</li> <li>all functions with an <code>apply</code> parameter have been removed - if you need them use the overloads with the <code>mapper</code> parameter instead, those are more flexible as they also allow you to convert the data type.</li> <li><code>lifecycle</code> functions have been moved from <code>androidMain</code> to <code>commonMain</code> - they are now available for all platforms</li> </ul> <p>The reason why I made a changing break update is mostly the last point - moving lifecycle functions to <code>commonMain</code> breaks the compatibility with previous versions. So I also made the clean up of removing the mapped functions and apply parameters while I was at it.</p>"},{"location":"modules/compose/","title":"Compose","text":"<p>This module is placed inside the <code>extension-compose</code> artifact and offers some helpful compose extensions for the <code>Storage</code> class.</p> <p>All extensions functions are on <code>StorageSetting&lt;T&gt;</code> and following are available:</p> <p>Available extensions are listed below:</p> <code>StorageSetting&lt;T&gt;.collectAsState(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsState(\n    initialValue: T? = getCachedValue()\n): State&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsState(\n    initialValue: T? = getCachedValue(),\n    mapper: (T) -&gt; X,\n): State&lt;X?&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.collectAsStateNotNull(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsStateNotNull(\n    initialValue: T = getValueNotNull()\n): State&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsStateNotNull(\n    initialValue: T = getValueNotNull(),\n    mapper: (T) -&gt; X,\n): State&lt;X&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.collectAsStateWithLifecycle(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycle(\n    lifecycle: Lifecycle,\n    initialValue: T? = tryGetValueNotNull(),\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext\n): State&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycle(\n    lifecycle: Lifecycle,\n    initialValue: T? = tryGetValueNotNull(),\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n): State&lt;X?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycle(\n    initialValue: T? = tryGetValueNotNull(),\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext\n): State&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycle(\n    initialValue: T? = tryGetValueNotNull(),\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n): State&lt;X?&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.collectAsStateWithLifecycleNotNull(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycleNotNull(\n    lifecycle: Lifecycle,\n    initialValue: T = getValueNotNull(),\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n): State&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycleNotNull(\n    lifecycle: Lifecycle,\n    initialValue: T = getValueNotNull(),\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n): State&lt;X&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycleNotNull(\n    initialValue: T = getValueNotNull(),\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext\n): State&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.collectAsStateWithLifecycleNotNull(\n    initialValue: T = getValueNotNull(),\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n): State&lt;X&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asMutableState(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableState(): MutableState&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.asMutableState(\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X?&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asMutableStateNotNull(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableStateNotNull(): MutableState&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T : Any, X : Any&gt; StorageSetting&lt;T&gt;.asMutableStateNotNull(\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asMutableStateWithLifecycle(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycle(\n    lifecycle: Lifecycle,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n): MutableState&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycle(\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n): MutableState&lt;T?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycle(\n    lifecycle: Lifecycle,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X?&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T, X&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycle(\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X?&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asMutableStateWithLifecycleNotNull(...)</code> functions <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycleNotNull(\n    lifecycle: Lifecycle,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n): MutableState&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycleNotNull(\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n): MutableState&lt;T&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T : Any, X : Any&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycleNotNull(\n    lifecycle: Lifecycle,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X&gt;\n</code></pre> <pre><code>@Composable\nfun &lt;T : Any, X : Any&gt; StorageSetting&lt;T&gt;.asMutableStateWithLifecycleNotNull(\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,\n    context: CoroutineContext = EmptyCoroutineContext,\n    mapper: (T) -&gt; X,\n    unmapper: (X) -&gt; T,\n): MutableState&lt;X&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asStateFlow(...)</code> functions <pre><code>fun &lt;T&gt; StorageSetting&lt;T&gt;.asStateFlow(\n    scope: CoroutineScope,\n    started: SharingStarted = SharingStarted.WhileSubscribed(5_000)\n): StateFlow&lt;T?&gt;\n</code></pre> <pre><code>fun &lt;T&gt; StorageSetting&lt;T&gt;.asStateFlow(\n    scope: CoroutineScope,\n    started: SharingStarted = SharingStarted.WhileSubscribed(5_000)\n): StateFlow&lt;T?&gt;\n</code></pre> <code>StorageSetting&lt;T&gt;.asStateFlowNotNull(...)</code> functions <pre><code>fun &lt;T&gt; StorageSetting&lt;T&gt;.asStateFlowNotNull(\n    scope: CoroutineScope,\n    started: SharingStarted = SharingStarted.WhileSubscribed(5_000)\n): StateFlow&lt;T&gt;\n</code></pre> <pre><code>fun &lt;T, T2&gt; StorageSetting&lt;T&gt;.asStateFlowNotNull(\n    scope: CoroutineScope,\n    mapper: (T) -&gt; T2,\n    started: SharingStarted = SharingStarted.WhileSubscribed(5_000),\n): StateFlow&lt;T2&gt;\n</code></pre>"},{"location":"modules/datastore/","title":"Datastore","text":"<p>The <code>Storage</code> is an abstraction to support any storage implementation. The <code>storage-datastore</code> module provides an implementation based on the Android JetPack DataStore.</p> <p>This module is placed inside the <code>storage-datastore</code> artifact and can simply be used like following:</p> Android/iOSJVM <pre><code>object SettingsModel : SettingsModel(\n    DataStoreStorage.create(\n        name: String = \"settings\",\n        encryption: StorageEncryption? = null,\n        cache: Boolean = true\n    )\n) {\n    // ...\n}\n</code></pre> <pre><code>object SettingsModel : SettingsModel(\n    DataStoreStorage.create(\n        folder: File,\n        name: String = \"settings\",\n        encryption: StorageEncryption? = null,\n        cache: Boolean = true\n    )\n) {\n    // ...\n}\n</code></pre>"},{"location":"modules/encryption/","title":"Encryption","text":"<p>Note</p> <p>This extension does only support android!</p> <p>Currently there only exists the AES encryption module. It simple implements a predefined interface that encrypts and decrypts all data before it get's persisted by a storage implementation.</p> <p>This module is placed inside the <code>encrpytion-aes</code> artifact and can simply be used like following:</p>"},{"location":"modules/encryption/#step-12-define-the-encryption","title":"Step 1/2: define the encryption","text":"<pre><code>private const val ALGORITHM = StorageEncryptionAES.DEFAULT_ALGORITHM\nprivate const val KEY_ALGORITHM = StorageEncryptionAES.DEFAULT_KEY_ALGORITHM\n// also check out StorageEncryptionAES::generateKey and StorageEncryptionAES::generateIv if you need some helper functions\nprivate val KEY = StorageEncryptionAES.getKeyFromPassword(KEY_ALGORITHM, \"my key\", \"my salt\")\nprivate val BYTE_ARRAY = listOf(0x16, 0x09, 0xc0, 0x4d, 0x4a, 0x09, 0xd2, 0x46, 0x71, 0xcc, 0x32, 0xb7, 0xd2, 0x91, 0x8a, 0x9c)\n    .map { it.toByte() }\n    .toByteArray()\nprivate val IV = StorageEncryptionAES.getIv(BYTE_ARRAY) // byte array must be 16 bytes!\nval ENCRYPTION = StorageEncryptionAES(ALGORITHM, KEY, IV)\n</code></pre>"},{"location":"modules/encryption/#step-22-attach-the-encryption-to-your-storage-instance","title":"Step 2/2: attach the encryption to your storage instance","text":"<pre><code>object MyEncryptedSettingsModel : SettingsModel(\n    DataStoreStorage(\n        name = \"encrypted\",\n        encryption = ENCRYPTION\n    )\n) {\n    // ...\n}\n</code></pre>"},{"location":"modules/key-value/","title":"Key Value","text":"<p>The <code>Storage</code> is an abstraction to support any storage implementation. The <code>storage-keyvalue</code> module provides an implementation based on a plain text file that will look like following:</p> <pre><code>key1=value1\nkey2=value2\n</code></pre> <p>This module is placed inside the <code>storage-keyvalue</code> artifact and can simply be used like following:</p> Android/iOSJVM <pre><code>object SettingsModel : SettingsModel(\n    KeyValueStorage.create(\n        fileName: String = \"settings.txt\",\n        delimiter: String = \"=\",\n        encryption: StorageEncryption? = null,\n        cache: Boolean = true\n    )\n) {\n    // ...\n}\n</code></pre> <pre><code>object SettingsModel : SettingsModel(\n    KeyValueStorage.create(\n        folder = File(System.getProperty(\"user.dir\")),\n        fileName = \"data.txt\",\n        delimiter: String = \"=\",\n        encryption: StorageEncryption? = null,\n        cache: Boolean = true\n    )\n) {\n    // ...\n}\n</code></pre>"}]}